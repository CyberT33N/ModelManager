/*
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñà‚ñà******************** PRESENTED BY t33n Software ***************************‚ñà‚ñà
‚ñà‚ñà                                                                           ‚ñà‚ñà
‚ñà‚ñà                  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó                      ‚ñà‚ñà
‚ñà‚ñà                  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë                      ‚ñà‚ñà
‚ñà‚ñà                     ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë                      ‚ñà‚ñà
‚ñà‚ñà                     ‚ñà‚ñà‚ïë    ‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó ‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë                      ‚ñà‚ñà
‚ñà‚ñà                     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë                      ‚ñà‚ñà
‚ñà‚ñà                     ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù                      ‚ñà‚ñà
‚ñà‚ñà                                                                           ‚ñà‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
*/

// üåü ==== DEPENDENCIES ====
import mongoose from 'mongoose'

import {
    describe, it,
    expect, expectTypeOf,
    beforeEach, beforeAll
} from 'vitest'

// üîå ==== INTERNAL ====
import type { IModel } from '@/src/ModelManager'

// üõ†Ô∏è ==== CODE TO TEST ====
import MongooseUtils from '@/src/MongooseUtils'
import type { IMongooseSchema } from '@/test/models/Test.model.ts'

// üß™ Describe test suite for MongooseUtils type tests
describe('[TYPE TEST] - src/MongooseUtils.ts', () => {
    let mongooseUtils: MongooseUtils // üõ†Ô∏è Instance of MongooseUtils
    let modelDetails: IModel<any> // üìä Model details

    // üîÑ Setup before all tests
    beforeAll(() => {
        modelDetails = globalThis.modelDetails // üì¶ Assign model details from global context
    })

    // üîÑ Reset instances before each test
    beforeEach(() => {
        MongooseUtils['instances'] = new Map() // üóÑÔ∏è Reset the instances map

        mongooseUtils = MongooseUtils.getInstance(modelDetails.dbName) // üîó Get MongooseUtils instance
        expect(mongooseUtils).toBeInstanceOf(MongooseUtils) // ‚úÖ Verify instance type
    })

    // üìú Test for getInstance method
    describe('getInstance()', () => {
        it('should verify param and return type', () => {
            expectTypeOf(MongooseUtils.getInstance.bind(MongooseUtils)).toBeCallableWith(
                modelDetails.dbName // üì¶ Check if it accepts dbName
            )
            expectTypeOf(MongooseUtils.getInstance.bind(MongooseUtils)).returns
                .toEqualTypeOf<MongooseUtils>() // üîç Verify return type
        })
    })

    // üìú Test methods within MongooseUtils
    describe('[METHODS]', () => {
        // ‚öôÔ∏è Static methods section
        describe('[STATIC]', () => {
            // üìù Test createSchema method
            describe('createSchema()', () => {
                it('should verify param and return type', () => {
                    const { modelName, schema } = modelDetails // üì¶ Destructure model details

                    expectTypeOf(
                        MongooseUtils.createSchema.bind(MongooseUtils)
                    ).toBeCallableWith(schema, { collection: modelName }) // üìã Check params

                    expectTypeOf(
                        MongooseUtils.createSchema.bind(MongooseUtils)<IMongooseSchema>
                    ).returns
                        .toEqualTypeOf<mongoose.Schema<IMongooseSchema>>() // üîç Verify return type
                })
            })
        })

        // ‚öôÔ∏è Private methods section
        describe('[PRIVATE]', () => {
            // üõ†Ô∏è Test init method
            describe('init()', () => {
                it('should verify return type', () => {
                    expectTypeOf(mongooseUtils['init']).returns.resolves.toBeVoid()
                })
            })

            // üõ†Ô∏è Test updateConnectionString method
            describe('updateConnectionString()', () => {
                it('should verify return type', () => {
                    expectTypeOf(mongooseUtils['updateConnectionString']).returns.toBeVoid()
                })
            })
        })

        // ‚öôÔ∏è Public methods section
        describe('[PUBLIC]', () => {
            // üõ†Ô∏è Test getConnection method
            describe('getConnection()', () => {
                it('should verify return type', () => {
                    expectTypeOf(mongooseUtils.getConnection.bind(mongooseUtils)).returns.resolves
                        .toEqualTypeOf<mongoose.Connection>()
                })
            })

            // üõ†Ô∏è Test createModel method
            describe('createModel()', () => {
                it('should verify param and return type', () => {
                    const { modelName, schema } = modelDetails

                    expectTypeOf(
                        mongooseUtils.createModel.bind(mongooseUtils)
                    ).toBeCallableWith(schema, modelName)

                    expectTypeOf(
                        mongooseUtils.createModel.bind(mongooseUtils)<IMongooseSchema>
                    ).returns.resolves
                        .toEqualTypeOf<mongoose.Model<IMongooseSchema>>()
                })
            })
        })
    })
})
